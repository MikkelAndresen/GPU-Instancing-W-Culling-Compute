#pragma kernel CSMain

// Overview:
// Inputs:
// * Camera frustum planes
// * OBB Array
// * 

// Outputs
// * Possibly AABB Array, unless we discard them
// * Index array

// Take OBB array, transform each element into an AABB
// Compare AABB to camera frustum
// Append index used to get OBB to output index array

//StructuredBuffer<Bounds> BoundsData;
StructuredBuffer<float3x4> Input;
AppendStructuredBuffer<uint> Output;
uint _Length = 0;
float3 _CameraPos;
float _MaxDistance = -1;

// Taken from https://tavianator.com/2011/ray_box.html
//bool BoundsIntersection(in Bounds b, Ray ray) {
//    float tx1 = (b.Min.x - ray.origin.x)*ray.inverseDirection.x;
//    float tx2 = (b.Max.x - ray.origin.x)*ray.inverseDirection.x;

//    float tmin = min(tx1, tx2);
//    float tmax = max(tx1, tx2);

//    float ty1 = (b.Min.y - ray.origin.y)*ray.inverseDirection.y;
//    float ty2 = (b.Max.y - ray.origin.y)*ray.inverseDirection.y;

//    tmin = max(tmin, min(ty1, ty2));
//    tmax = min(tmax, max(ty1, ty2));

//    return tmax >= tmin;
//}

[numthreads(4,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if(id.x + 1 >= _Length)
		return;

	//float3x4 mat = Input[id.x];
	//float3 pos = float3(mat[0][3], mat[1][3], mat[2][3]);
	
	//float distance = length(_CameraPos - pos);
	//float normalizedDistance = distance/5;
	//float oneMinusNormDist = 1-normalizedDistance;
	//Input[id.x].color = float4(oneMinusNormDist, 0,0,1);

	//if((_MaxDistance > 0 || distance <= _MaxDistance))
	//if(oneMinusNormDist > 0)
	Output.Append(id.x);
}